task:
  name: Memory Task Template
  description: Template showing how to properly use memory functions in tasks that might be called via subprocess
  version: "1.0"
  author: SEMAD-Method Team
  category: memory
  complexity: low
  elicit: false
  tags:
    - memory
    - template

process:
  steps:
    - name: Load Memory Utils
      instructions: |
        Load the appropriate memory management utilities based on execution context:
        ```javascript
        // IMPORTANT: Check execution context and use appropriate functions
        
        // If running in a subprocess (node -e), use exit-safe versions:
        if (typeof process !== 'undefined' && process.argv[1] === '-e') {
          const { 
            loadAgentMemoryContextAndExit,
            retrieveRelevantMemoriesAndExit,
            updateWorkingMemoryAndExit,
            saveToLongTermMemoryAndExit 
          } = require('.bmad-core/utils/agent-memory-loader.js');
          
          // Use exit-safe functions
          const loadMemory = loadAgentMemoryContextAndExit;
          const retrieveMemories = retrieveRelevantMemoriesAndExit;
          const updateMemory = updateWorkingMemoryAndExit;
          const saveMemory = saveToLongTermMemoryAndExit;
        } else {
          // Running in main process, use regular versions:
          const { 
            loadAgentMemoryContext 
          } = require('.bmad-core/utils/agent-memory-loader.js');
          const { 
            retrieveRelevantMemories,
            updateWorkingMemory,
            saveToLongTermMemory 
          } = require('.bmad-core/utils/agent-memory-manager.js');
          
          // Use regular functions
          const loadMemory = loadAgentMemoryContext;
          const retrieveMemories = retrieveRelevantMemories;
          const updateMemory = updateWorkingMemory;
          const saveMemory = saveToLongTermMemory;
        }
        
        const agentName = 'YOUR_AGENT_NAME'; // Replace with actual agent name
        ```

    - name: Example Usage
      instructions: |
        Use the functions loaded above:
        ```javascript
        // Load agent memory context
        const memoryContext = await loadMemory(agentName, {
          storyId: 'story-123',
          epicId: 'epic-456'
        });
        
        // Retrieve relevant memories
        const memories = await retrieveMemories(agentName, 'search query', {
          topN: 5,
          storyId: 'story-123'
        });
        
        // Update working memory
        await updateMemory(agentName, {
          observations: [{
            content: 'New observation',
            timestamp: new Date().toISOString()
          }]
        });
        
        // Save to long-term memory
        await saveMemory(agentName, {
          content: 'Important pattern to remember',
          metadata: {
            importance: 'high',
            storyId: 'story-123'
          }
        });
        ```

notes: |
  ## Important Notes for Memory Tasks
  
  1. **Subprocess Detection**: Tasks executed via `node -e` must use exit-safe functions
  2. **Exit-Safe Functions**: These functions close Qdrant connections and force process exit
  3. **Regular Functions**: Use these when running in the main agent process
  4. **All Agents Affected**: dev, qa, sm, analyst, pm, architect all need this pattern
  
  ## Migration Guide
  
  To update existing memory tasks:
  1. Replace direct imports with the conditional loading pattern above
  2. Use the function aliases (loadMemory, updateMemory, etc.) throughout the task
  3. Test both execution contexts (main process and subprocess)