/**
 * Dependency Analysis Storage Utilities
 * 
 * Provides consistent file naming and storage location for dependency impact analysis
 * reports generated by dev agent and consumed by QA agent.
 */

const fs = require('fs').promises;
const path = require('path');

// Configuration for storage paths
const STORAGE_CONFIG = {
  // Base directory for all dependency analyses
  BASE_DIR: '.ai/dependency-analyses',
  
  // Subdirectories by type
  SUBDIRS: {
    DEV: 'dev-analysis',      // Pre-implementation analysis by dev
    QA: 'qa-comparison',      // QA comparison reports
    ARCHIVE: 'archive'        // Archived analyses from completed stories
  }
};

/**
 * Ensures the dependency analysis directory structure exists
 */
async function ensureStorageDirectories() {
  const dirs = [
    STORAGE_CONFIG.BASE_DIR,
    path.join(STORAGE_CONFIG.BASE_DIR, STORAGE_CONFIG.SUBDIRS.DEV),
    path.join(STORAGE_CONFIG.BASE_DIR, STORAGE_CONFIG.SUBDIRS.QA),
    path.join(STORAGE_CONFIG.BASE_DIR, STORAGE_CONFIG.SUBDIRS.ARCHIVE)
  ];
  
  for (const dir of dirs) {
    try {
      await fs.access(dir);
    } catch (error) {
      if (error.code === 'ENOENT') {
        await fs.mkdir(dir, { recursive: true });
      } else {
        throw error;
      }
    }
  }
}

/**
 * Generates a consistent filename for dependency analysis
 * Format: dep-analysis-{storyId}-{taskId}-{timestamp}.md
 * 
 * @param {string} storyId - The story ID (e.g., "story-16")
 * @param {string} taskId - The task ID or "full-story" for complete analysis
 * @param {string} type - Type of analysis: 'dev' or 'qa'
 * @returns {string} The generated filename
 */
function generateAnalysisFilename(storyId, taskId = 'full-story', type = 'dev') {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5); // YYYY-MM-DDTHH-MM-SS
  const sanitizedStoryId = storyId.replace(/[^a-zA-Z0-9-]/g, '-');
  const sanitizedTaskId = taskId.replace(/[^a-zA-Z0-9-]/g, '-');
  
  return `dep-analysis-${sanitizedStoryId}-${sanitizedTaskId}-${timestamp}.md`;
}

/**
 * Gets the full path for saving a dependency analysis
 * 
 * @param {string} filename - The filename generated by generateAnalysisFilename
 * @param {string} type - Type of analysis: 'dev' or 'qa'
 * @returns {string} Full path to save the file
 */
function getAnalysisPath(filename, type = 'dev') {
  const subdir = type === 'qa' ? STORAGE_CONFIG.SUBDIRS.QA : STORAGE_CONFIG.SUBDIRS.DEV;
  return path.join(STORAGE_CONFIG.BASE_DIR, subdir, filename);
}

/**
 * Saves a dependency analysis report
 * 
 * @param {string} storyId - The story ID
 * @param {string} taskId - The task ID or "full-story"
 * @param {string} analysisContent - The analysis report content
 * @param {object} metadata - Additional metadata to save
 * @param {string} type - Type of analysis: 'dev' or 'qa'
 * @returns {object} Information about the saved file
 */
async function saveDependencyAnalysis(storyId, taskId, analysisContent, metadata = {}, type = 'dev') {
  await ensureStorageDirectories();
  
  const filename = generateAnalysisFilename(storyId, taskId, type);
  const filepath = getAnalysisPath(filename, type);
  
  // Create enhanced content with metadata
  const fullContent = `# Dependency Impact Analysis Report

**Story ID**: ${storyId}
**Task ID**: ${taskId}
**Analysis Type**: ${type}
**Generated**: ${new Date().toISOString()}
**Agent**: ${metadata.agent || 'dev'}

## Metadata
\`\`\`json
${JSON.stringify(metadata, null, 2)}
\`\`\`

---

${analysisContent}`;
  
  await fs.writeFile(filepath, fullContent, 'utf8');
  
  // Also create a latest symlink for easy access
  const latestLink = path.join(
    STORAGE_CONFIG.BASE_DIR, 
    type === 'qa' ? STORAGE_CONFIG.SUBDIRS.QA : STORAGE_CONFIG.SUBDIRS.DEV,
    `latest-${storyId}.md`
  );
  
  // Remove existing symlink if it exists
  try {
    await fs.unlink(latestLink);
  } catch (error) {
    // Ignore if doesn't exist
  }
  
  // Create relative symlink
  const relativeTarget = path.relative(path.dirname(latestLink), filepath);
  await fs.symlink(relativeTarget, latestLink);
  
  return {
    filename,
    filepath,
    latestLink,
    timestamp: new Date().toISOString()
  };
}

/**
 * Retrieves the most recent dependency analysis for a story
 * 
 * @param {string} storyId - The story ID
 * @param {string} taskId - The task ID (optional, defaults to any)
 * @param {string} type - Type of analysis: 'dev' or 'qa'
 * @returns {object|null} The analysis content and metadata, or null if not found
 */
async function getLatestDependencyAnalysis(storyId, taskId = null, type = 'dev') {
  try {
    // First try the latest symlink
    const latestLink = path.join(
      STORAGE_CONFIG.BASE_DIR,
      type === 'qa' ? STORAGE_CONFIG.SUBDIRS.QA : STORAGE_CONFIG.SUBDIRS.DEV,
      `latest-${storyId}.md`
    );
    
    try {
      const content = await fs.readFile(latestLink, 'utf8');
      const realPath = await fs.realpath(latestLink);
      return {
        content,
        filepath: realPath,
        filename: path.basename(realPath),
        isLatest: true
      };
    } catch (error) {
      // Fallback to searching for files
    }
    
    // Search for matching files
    const subdir = type === 'qa' ? STORAGE_CONFIG.SUBDIRS.QA : STORAGE_CONFIG.SUBDIRS.DEV;
    const searchDir = path.join(STORAGE_CONFIG.BASE_DIR, subdir);
    
    const files = await fs.readdir(searchDir);
    const pattern = taskId 
      ? `dep-analysis-${storyId}-${taskId}-`
      : `dep-analysis-${storyId}-`;
    
    const matchingFiles = files
      .filter(f => f.startsWith(pattern) && f.endsWith('.md'))
      .sort((a, b) => b.localeCompare(a)); // Sort by timestamp (newest first)
    
    if (matchingFiles.length === 0) {
      return null;
    }
    
    const filepath = path.join(searchDir, matchingFiles[0]);
    const content = await fs.readFile(filepath, 'utf8');
    
    return {
      content,
      filepath,
      filename: matchingFiles[0],
      isLatest: false
    };
  } catch (error) {
    console.error('Error retrieving dependency analysis:', error.message);
    return null;
  }
}

/**
 * Lists all dependency analyses for a story
 * 
 * @param {string} storyId - The story ID
 * @param {string} type - Type of analysis: 'dev', 'qa', or 'all'
 * @returns {array} List of analysis files with metadata
 */
async function listDependencyAnalyses(storyId, type = 'all') {
  const results = [];
  
  const dirs = type === 'all' 
    ? [STORAGE_CONFIG.SUBDIRS.DEV, STORAGE_CONFIG.SUBDIRS.QA]
    : [type === 'qa' ? STORAGE_CONFIG.SUBDIRS.QA : STORAGE_CONFIG.SUBDIRS.DEV];
  
  for (const subdir of dirs) {
    try {
      const searchDir = path.join(STORAGE_CONFIG.BASE_DIR, subdir);
      const files = await fs.readdir(searchDir);
      
      const matchingFiles = files.filter(f => 
        f.includes(`-${storyId}-`) && f.endsWith('.md') && !f.startsWith('latest-')
      );
      
      for (const file of matchingFiles) {
        const filepath = path.join(searchDir, file);
        const stats = await fs.stat(filepath);
        
        // Parse filename for metadata
        const parts = file.match(/dep-analysis-(.+?)-(.+?)-(.+?)\.md/);
        
        results.push({
          filename: file,
          filepath,
          storyId: parts ? parts[1] : storyId,
          taskId: parts ? parts[2] : 'unknown',
          timestamp: parts ? parts[3] : stats.mtime.toISOString(),
          type: subdir === STORAGE_CONFIG.SUBDIRS.QA ? 'qa' : 'dev',
          size: stats.size,
          modified: stats.mtime
        });
      }
    } catch (error) {
      console.error(`Error listing analyses in ${subdir}:`, error.message);
    }
  }
  
  return results.sort((a, b) => b.modified - a.modified);
}

/**
 * Archives dependency analyses for completed stories
 * 
 * @param {string} storyId - The story ID to archive
 * @returns {object} Archive operation results
 */
async function archiveDependencyAnalyses(storyId) {
  const archived = [];
  const errors = [];
  
  const dirs = [STORAGE_CONFIG.SUBDIRS.DEV, STORAGE_CONFIG.SUBDIRS.QA];
  
  for (const subdir of dirs) {
    try {
      const searchDir = path.join(STORAGE_CONFIG.BASE_DIR, subdir);
      const files = await fs.readdir(searchDir);
      
      const matchingFiles = files.filter(f => 
        f.includes(`-${storyId}-`) && f.endsWith('.md')
      );
      
      for (const file of matchingFiles) {
        try {
          const srcPath = path.join(searchDir, file);
          const destPath = path.join(STORAGE_CONFIG.BASE_DIR, STORAGE_CONFIG.SUBDIRS.ARCHIVE, file);
          
          await fs.rename(srcPath, destPath);
          archived.push({ file, from: subdir, to: STORAGE_CONFIG.SUBDIRS.ARCHIVE });
        } catch (error) {
          errors.push({ file, error: error.message });
        }
      }
    } catch (error) {
      errors.push({ directory: subdir, error: error.message });
    }
  }
  
  return { archived, errors };
}

module.exports = {
  STORAGE_CONFIG,
  ensureStorageDirectories,
  generateAnalysisFilename,
  getAnalysisPath,
  saveDependencyAnalysis,
  getLatestDependencyAnalysis,
  listDependencyAnalyses,
  archiveDependencyAnalyses
};